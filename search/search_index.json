{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Software Design/Architecture &amp; Data Engineering","text":"<p>Bienvenue dans ce cours d\u00e9di\u00e9 au Software Design, \u00e0 l'Architecture Logicielle et au Data Engineering.</p> <p>Ce cours a pour objectif de vous fournir les bases solides et les meilleures pratiques pour concevoir des syst\u00e8mes robustes, \u00e9volutifs et performants.</p>"},{"location":"#software-design","title":"Software Design","text":"<ul> <li>Type Hint : Comprendre et utiliser le typage statique en Python pour am\u00e9liorer la qualit\u00e9 et la robustesse du code.</li> <li>Data Structure : Ma\u00eetriser les structures de donn\u00e9es en Python (types num\u00e9riques, strings, bool\u00e9ens, enums, collections) avec des exemples pratiques et des consid\u00e9rations de performance.</li> <li>Class et Dataclass : Comprendre les classes, les m\u00e9thodes dunder, les dataclasses et leurs fonctionnalit\u00e9s avanc\u00e9es (order, frozen, slots, default_factory), ainsi que l'alternative Pydantic.</li> </ul>"},{"location":"cours-1-type-hint/","title":"Type Hint","text":"<p>Des langages comme Java, C# ou encore C++ ont des types dans leur syntaxe. Python n'en a pas, ce qui peut engendrer des erreurs.</p>"},{"location":"cours-1-type-hint/#pourquoi-utilise-t-on-les-types","title":"Pourquoi utilise-t-on les types ?","text":"<p>Les types permettent de faciliter la lecture du code ; c'est une sorte de documentation. Ils peuvent \u00e9galement permettre \u00e0 des \"static type checkers\" (v\u00e9rificateurs de type statiques) de v\u00e9rifier s'il n'y a pas d'erreur de type.</p> <p>Ils aident les d\u00e9veloppeurs avec qui vous travaillez \u00e0 mieux savoir ce qui est attendu en entr\u00e9e et en sortie.</p>"},{"location":"cours-1-type-hint/#les-differents-types-de-typage","title":"Les diff\u00e9rents types de typage","text":""},{"location":"cours-1-type-hint/#static-vs-dynamic","title":"Static vs Dynamic","text":"<p>Typage statique : Les types sont v\u00e9rifi\u00e9s \u00e0 la compilation (avant l'ex\u00e9cution). Si une erreur de type existe, le programme ne compile pas. Exemples : Java, C#, C++, TypeScript</p> <p>Typage dynamique : Les types sont v\u00e9rifi\u00e9s \u00e0 l'ex\u00e9cution. Une erreur de type ne sera d\u00e9tect\u00e9e que lorsque le code probl\u00e9matique est ex\u00e9cut\u00e9. Exemples : Python, JavaScript, Ruby</p> <pre><code># Python est dynamiquement typ\u00e9 : on peut changer le type d'une variable\nx = 5        # x est un int\nx = \"hello\"  # x devient un str \u2192 aucune erreur !\n\n# Avec mypy, on peut d\u00e9tecter les erreurs de type AVANT l'ex\u00e9cution\ndef greet(name: str) -&gt; str:\n    return \"Hello \" + name\n\n# greet(123)  # \u274c mypy d\u00e9tecte l'erreur, mais Python l'ex\u00e9cute quand m\u00eame\n</code></pre> <p>Python est un langage dynamiquement typ\u00e9, mais les type hints permettent d'ajouter une v\u00e9rification \"statique\" gr\u00e2ce \u00e0 des outils comme <code>mypy</code> ou <code>pyright</code>.</p>"},{"location":"cours-1-type-hint/#manifest-vs-inferred","title":"Manifest vs Inferred","text":"<p>Manifest (explicite) : Le d\u00e9veloppeur doit d\u00e9clarer explicitement les types dans le code. Exemples : Java, C (<code>int x = 5;</code>)</p> <p>Inferred (inf\u00e9r\u00e9) : Le compilateur/interpr\u00e9teur d\u00e9duit automatiquement le type \u00e0 partir de la valeur. Exemples : TypeScript, Kotlin, Python avec type hints (<code>x = 5</code> \u2192 le type <code>int</code> est inf\u00e9r\u00e9)</p> <pre><code># Manifest : on d\u00e9clare explicitement le type\nage: int = 25\nname: str = \"Alice\"\n\n# Inferred : mypy/pyright d\u00e9duit le type automatiquement\nage = 25      # mypy sait que c'est un int\nname = \"Alice\"  # mypy sait que c'est un str\n\n# L'inf\u00e9rence fonctionne aussi pour les retours de fonction\ndef get_age():\n    return 25  # mypy inf\u00e8re que le retour est int\n</code></pre> <p>Python supporte les deux : on peut \u00e9crire <code>x: int = 5</code> (manifest) ou laisser l'outil inf\u00e9rer le type.</p>"},{"location":"cours-1-type-hint/#nominal-vs-structural","title":"Nominal vs Structural","text":"<p>Nominal : Deux types sont compatibles uniquement s'ils ont le m\u00eame nom (ou une relation d'h\u00e9ritage explicite). Exemples : Java, C# \u2014 <code>class Dog</code> et <code>class Cat</code> sont incompatibles m\u00eame s'ils ont les m\u00eames attributs.</p> <p>Structural : Deux types sont compatibles s'ils ont la m\u00eame structure (m\u00eames attributs/m\u00e9thodes), peu importe leur nom. Exemples : TypeScript, Go \u2014 si deux objets ont les m\u00eames propri\u00e9t\u00e9s, ils sont compatibles.</p> <pre><code>from typing import Protocol\n\n# Typage NOMINAL : Dog et Cat sont incompatibles malgr\u00e9 la m\u00eame structure\nclass Dog:\n    def speak(self) -&gt; str:\n        return \"Woof\"\n\nclass Cat:\n    def speak(self) -&gt; str:\n        return \"Meow\"\n\ndef make_dog_speak(dog: Dog) -&gt; str:\n    return dog.speak()\n\n# make_dog_speak(Cat())  # \u274c Erreur : Cat n'est pas Dog\n\n# Typage STRUCTURAL avec Protocol : on v\u00e9rifie la structure, pas le nom\nclass Speaker(Protocol):\n    def speak(self) -&gt; str: ...\n\ndef make_speak(animal: Speaker) -&gt; str:\n    return animal.speak()\n\nmake_speak(Dog())  # \u2705 OK : Dog a une m\u00e9thode speak()\nmake_speak(Cat())  # \u2705 OK : Cat a une m\u00e9thode speak()\n</code></pre> <p>Python avec les type hints utilise principalement le typage nominal, mais les <code>Protocol</code> permettent un typage structural (duck typing v\u00e9rifi\u00e9 statiquement).</p>"},{"location":"cours-1-type-hint/#duck-typing","title":"Duck Typing \ud83e\udd86","text":"<p>Le duck typing est la philosophie de Python :</p> <p>\"If it walks like a duck and quacks like a duck, then it must be a duck.\" (Si \u00e7a marche comme un canard et \u00e7a fait coin-coin comme un canard, alors c'est un canard.)</p> <p>En pratique : on ne v\u00e9rifie pas le type d'un objet, mais s'il poss\u00e8de les m\u00e9thodes/attributs dont on a besoin.</p> <pre><code># Duck typing classique (sans type hints) :\ndef make_sound(animal):\n    print(animal.speak())  # On s'en fiche du type, tant qu'il a une m\u00e9thode speak()\n\nclass Duck:\n    def speak(self):\n        return \"Quack\"\n\nclass Person:\n    def speak(self):\n        return \"Hello\"\n\nmake_sound(Duck())    # \u2705 Fonctionne\nmake_sound(Person())  # \u2705 Fonctionne aussi !\n</code></pre> <p>\u26a0\ufe0f Probl\u00e8me : Les erreurs ne sont d\u00e9tect\u00e9es qu'\u00e0 l'ex\u00e9cution. Si on passe un objet sans m\u00e9thode <code>speak()</code>, on aura une <code>AttributeError</code> au runtime. Solution : Utiliser <code>Protocol</code> (voir section pr\u00e9c\u00e9dente) pour combiner duck typing + v\u00e9rification statique.</p>"},{"location":"cours-1-type-hint/#compiled-vs-interpreted","title":"Compiled vs Interpreted","text":"<p>Langage compil\u00e9 : Le code source est traduit enti\u00e8rement en code machine (binaire) par un compilateur avant l'ex\u00e9cution. Le r\u00e9sultat est un ex\u00e9cutable autonome. Exemples : C, C++, Rust, Go</p> <p>Langage interpr\u00e9t\u00e9 : Le code source est lu et ex\u00e9cut\u00e9 ligne par ligne par un interpr\u00e9teur au moment de l'ex\u00e9cution. Exemples : JavaScript (historiquement), Bash</p> <p>Et Python ? Python est un cas hybride : le code est d'abord compil\u00e9 en bytecode (fichiers <code>.pyc</code>), puis ce bytecode est interpr\u00e9t\u00e9 par la machine virtuelle Python (CPython). On dit souvent que Python est \"interpr\u00e9t\u00e9\" car cette compilation est transparente pour l'utilisateur.</p>"},{"location":"cours-1-type-hint/#avantages-et-inconvenients","title":"Avantages et inconv\u00e9nients","text":"Type Avantages Inconv\u00e9nients Compil\u00e9 Ex\u00e9cution tr\u00e8s rapide, optimisations du compilateur, erreurs d\u00e9tect\u00e9es avant l'ex\u00e9cution Temps de compilation, moins portable (d\u00e9pend de l'architecture), cycle de d\u00e9veloppement plus long Interpr\u00e9t\u00e9 D\u00e9veloppement rapide (modifier \u2192 relancer), plus portable, debugging plus facile Ex\u00e9cution plus lente, erreurs d\u00e9tect\u00e9es seulement \u00e0 l'ex\u00e9cution"},{"location":"cours-1-type-hint/#lien-entre-compilationinterpretation-et-typage","title":"Lien entre compilation/interpr\u00e9tation et typage","text":"<p>Le choix du syst\u00e8me de typage (statique vs dynamique) est souvent li\u00e9 au mode d'ex\u00e9cution du langage :</p> <p>Langages compil\u00e9s \u2192 souvent typ\u00e9s statiquement Le compilateur a besoin de conna\u00eetre les types \u00e0 l'avance pour g\u00e9n\u00e9rer du code machine optimis\u00e9. Conna\u00eetre le type permet d'allouer la bonne quantit\u00e9 de m\u00e9moire et d'utiliser les bonnes instructions CPU.</p> <p>Langages interpr\u00e9t\u00e9s \u2192 souvent typ\u00e9s dynamiquement L'interpr\u00e9teur peut inspecter les valeurs au moment de l'ex\u00e9cution, ce qui permet plus de flexibilit\u00e9 (ex: une variable peut changer de type en cours de route).</p> <p>\u26a0\ufe0f Attention : Ce n'est pas une r\u00e8gle absolue ! TypeScript est compil\u00e9 mais transpil\u00e9 en JavaScript. Go est compil\u00e9 et statiquement typ\u00e9 mais avec de l'inf\u00e9rence de types. Python est interpr\u00e9t\u00e9 mais supporte les type hints v\u00e9rifi\u00e9s statiquement.</p>"},{"location":"cours-1-type-hint/#quand-utiliser-le-typing-en-python","title":"Quand utiliser le typing en Python","text":"<p>Une mauvaise pratique est de l'utiliser quand on d\u00e9finit une variable. C'est de l'over-engineering car c'est d\u00e9j\u00e0 facile \u00e0 comprendre :</p> <pre><code>some_numbers: list[int] = [1, 2, 3, 4] # \u274c overengineering\nnumber: int = 5 # \u274c overengineering\nstring: str = \"lol\" # \u274c overengineering\nsome_numbers: list[int | float | str] = [1, 2, 3, 4] # \u274c overengineering\n</code></pre> <p>Le typage est particuli\u00e8rement utile pour la d\u00e9finition de fonctions et de m\u00e9thodes :</p> <pre><code>def verify_password(submitted_password: str, stored_hash: str) -&gt; bool:\n    return submitted_password == stored_hash\n</code></pre> <p>M\u00eame avec une valeur par d\u00e9faut, il est tout de m\u00eame conseill\u00e9 d'ajouter le typage :</p> <pre><code>def verify_password_2(submitted_password: str, stored_hash: str = \"123456\") -&gt; bool:\n    return submitted_password == stored_hash\n</code></pre> <p>Les classes peuvent aussi \u00eatre consid\u00e9r\u00e9es comme un type :</p> <pre><code>class Car:\n    def __init__(self, name: str, cost: int | float, brand: str):\n        self.name = name\n        self.cost = cost\n        self.brand = brand\n\ndef print_car(car: Car) -&gt; None:\n    print(f\"name : {car.name} | cost : {car.cost} | brand : {car.brand}\")\n\n\ncar = Car(name=\"S\u00e9rie 1\", cost=10000, brand=\"BMW\")\n</code></pre> <p>\u26a0\ufe0f Attention : Dans la vraie vie <code>print_car</code> devrait \u00eatre une m\u00e9thode de la classe pour ne pas violer le principe de <code>Principle of Least Knowledge (Law of Demeter)</code></p> <p>\u26a0\ufe0f Attention : <code>int | float</code> veut dire que l'argument peut \u00eatre un entier ou un flottant</p>"},{"location":"cours-1-type-hint/#les-typings-exotiques","title":"Les typings exotiques","text":""},{"location":"cours-1-type-hint/#sequence","title":"Sequence","text":"<p><code>Sequence</code> est un type tr\u00e8s utile pour repr\u00e9senter toute structure de donn\u00e9e ordonn\u00e9e et indexable (comme <code>list</code>, <code>tuple</code>, <code>str</code>), mais de mani\u00e8re immmuable (on ne peut pas modifier les \u00e9l\u00e9ments, juste les lire).</p> <p>C'est souvent pr\u00e9f\u00e9rable \u00e0 <code>list</code> si votre fonction a juste besoin de lire des \u00e9l\u00e9ments, car cela rend votre fonction compatible avec plus de types (ex: tuples).</p> <pre><code>import typing as t\n\ndef function_with_fixed_type(some_sequence: t.Sequence[str]) -&gt; str:\n    return some_sequence[1]\n</code></pre> <p>Si le contenu de la s\u00e9quence peut \u00eatre de n'importe quel type, on peut utiliser <code>Any</code> :</p> <pre><code>import typing as t\n\ndef function_with_not_fixed_type(some_sequence: t.Sequence[t.Any]) -&gt; t.Any:\n    return some_sequence[1]\n</code></pre>"},{"location":"cours-1-type-hint/#lunion","title":"L'Union","text":"<p>L'op\u00e9rateur <code>|</code> (ou <code>Union</code> dans les anciennes versions de Python) permet de sp\u00e9cifier qu'une variable peut accepter plusieurs types diff\u00e9rents.</p> <p>Par exemple, si une fonction peut prendre un entier OU un nombre flottant :</p> <pre><code>def some_function_add(value_1: int | float, value_2: int | float) -&gt; int | float:\n    return value_1 + value_2\n</code></pre>"},{"location":"cours-1-type-hint/#type-generique-typevar","title":"Type g\u00e9n\u00e9rique (TypeVar)","text":"<p>Les g\u00e9n\u00e9riques permettent d'\u00e9crire des fonctions flexibles qui acceptent diff\u00e9rents types tout en maintenant une relation stricte entre eux.</p> <p>Si vous utilisez <code>Any</code>, vous perdez l'information de type. Avec un <code>TypeVar</code>, vous dites : \"Je ne sais pas quel est ce type T, mais si tu me donnes une liste de T, je te renverrai un T\".</p> <p>Exemple :  - Si l'entr\u00e9e est <code>list[str]</code>, la sortie sera <code>str</code>. - Si l'entr\u00e9e est <code>list[int]</code>, la sortie sera <code>int</code>.</p> <pre><code>import typing as t\n\nU = t.TypeVar(\"U\")\n\n\ndef func_typevar(some_sequence: t.Sequence[U]) -&gt; U:\n    return some_sequence[1]\n\ndef func_typevar_second_version[T](some_sequence: t.Sequence[T]) -&gt; T:\n    return some_sequence[1]\n\ndef some_function_add_type_var_simpler(value_1: U, value_2: U) -&gt; U:\n    return value_1 + value_2\n\ndef some_function_add_type_var_compact[G](value_1: G, value_2: G) -&gt; G:\n    return value_1 + value_2\n</code></pre>"},{"location":"cours-1-type-hint/#callable","title":"Callable","text":"<p><code>Callable</code> est utilis\u00e9 pour typer des fonctions pass\u00e9es en argument (callbacks). La syntaxe est <code>Callable[[Arg1Type, ArgType2], ReturnType]</code>.</p>"},{"location":"cours-1-type-hint/#python-313-syntaxe-classique","title":"Python &lt; 3.13 (Syntaxe classique)","text":"<pre><code>import typing as t\n\ndef some_function(value_1: str, value_2: str) -&gt; str:\n    return value_1 + value_2\n\n\ndef some_function_bis(value_1: str, value_2: str) -&gt; list[str]:\n    return [value_1, value_2]\n\n\ndict_value: t.Callable[[str, str], str | list[str]] = {\n    \"some_key\": some_function,\n    \"some_key_bis\": some_function_bis,\n}\n</code></pre>"},{"location":"cours-1-type-hint/#python-312-nouvelle-syntaxe-type","title":"Python &gt;= 3.12 (Nouvelle syntaxe <code>type</code>)","text":"<p>Depuis Python 3.12, on peut utiliser le mot-cl\u00e9 <code>type</code> pour cr\u00e9er des alias de type plus lisibles.</p> <pre><code>import typing as t\n\ntype FunctionBluePrintStr = t.Callable[[str, str], str | list[str]]\n\n\ndef some_function(value_1: str, value_2: str) -&gt; str:\n    return value_1 + value_2\n\n\ndef some_function_bis(value_1: str, value_2: str) -&gt; list[str]:\n    return [value_1, value_2]\n\n\ndict_value: FunctionBluePrintStr = {\n    \"some_key\": some_function,\n    \"some_key_bis\": some_function_bis,\n}\n</code></pre>"},{"location":"cours-1-type-hint/#classe-et-generique","title":"Classe et G\u00e9n\u00e9rique","text":"<p>On peut aussi cr\u00e9er des classes g\u00e9n\u00e9riques. Cela est tr\u00e8s courant pour des structures de donn\u00e9es (comme une Pile, une File, ou un Wrapper).</p> <p>L'exemple ci-dessous montre : 1. Une classe g\u00e9n\u00e9rique <code>SomeClass[T]</code> 2. L'usage de <code>Self</code> pour indiquer qu'une m\u00e9thode retourne l'instance elle-m\u00eame (utile pour le \"method chaining\" ou les patterns Builder). 3. La diff\u00e9rence avec le typage par cha\u00eene de caract\u00e8res (forward reference).</p> <p>Exemple : - <code>SomeClass[str]</code> (ou <code>SomeClass(\"a\", \"b\")</code>) : <code>T</code> devient <code>str</code>, donc <code>get_values()</code> retournera un tuple de strings. - <code>SomeClass[int]</code> (ou <code>SomeClass(1, 2)</code>) : <code>T</code> devient <code>int</code>, donc <code>get_values()</code> retournera un tuple d'entiers.</p> <pre><code>import typing as t\n\nclass SomeClass[T]:\n    def __init__(self, some_value_generic: T, some_value_generic_bis: T) -&gt; None:\n        self.some_value_generic = some_value_generic\n        self.some_value_generic_bis = some_value_generic_bis\n\n    def get_values(self) -&gt; tuple[T, T]:\n        return (self.some_value_generic, self.some_value_generic_bis)\n\n\nclass SomeClassReturnItSelf:\n    def return_self(self) -&gt; t.Self:\n        return self\n\n\nclass SomeClassReturnInstance:\n    def return_instance(self) -&gt; \"SomeClassReturnInstance\":\n        return SomeClassReturnInstance()\n</code></pre>"},{"location":"cours-1-type-hint/#literal","title":"Literal","text":"<p><code>Literal</code> permet de restreindre une valeur non pas \u00e0 un type, mais \u00e0 un ensemble pr\u00e9cis de valeurs. C'est tr\u00e8s utile pour les modes d'ouverture de fichiers, les statuts, ou les options de configuration.</p> <pre><code>import typing as t\n\ntype Mode = t.Literal[\"r\", \"rb\", \"w\", \"wb\"]\n\ndef open_helper(file: str, mode: Mode) -&gt; str: ...\n</code></pre>"},{"location":"cours-1-type-hint/#protocol-checkable","title":"Protocol checkable","text":"<p>Par d\u00e9faut, les <code>Protocol</code> sont v\u00e9rifi\u00e9s uniquement par les outils d'analyse statique (mypy). Si vous voulez v\u00e9rifier si un objet respecte un protocole au moment de l'ex\u00e9cution (avec <code>isinstance</code>), vous devez d\u00e9corer votre protocole avec <code>@runtime_checkable</code>.</p> <pre><code>import typing as t\n\n@t.runtime_checkable\nclass Closable(t.Protocol):\n    def close(self): ...\n\n\nclass SomeClassCheckable:\n    def close(self):\n        print(\"lol\")\n\nisinstance(SomeClassCheckable(), Closable)\n</code></pre>"},{"location":"cours-1-type-hint/#protocol-vs-abstract-base-class-abc","title":"Protocol vs Abstract Base Class (ABC)","text":"<p>Les classes abstraites (<code>ABC</code>) et les Protocols permettent tous deux de d\u00e9finir des \"contrats\" que d'autres classes doivent respecter. Mais ils ont des diff\u00e9rences fondamentales :</p> Aspect ABC Protocol H\u00e9ritage requis \u2705 Oui, obligatoire \u274c Non (structural) V\u00e9rification \u00c0 l'ex\u00e9cution Statique (mypy) Compatible avec code existant \u274c Non \u2705 Oui Peut d\u00e9finir des impl\u00e9mentations \u2705 Oui \u274c Non (juste signatures)"},{"location":"cours-1-type-hint/#exemple-avec-abc-classe-abstraite","title":"Exemple avec ABC (classe abstraite)","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass Serializable(ABC):\n    @abstractmethod\n    def to_json(self) -&gt; str:\n        pass\n\n# \u274c PROBL\u00c8ME : On DOIT h\u00e9riter de Serializable\nclass User(Serializable):  # H\u00e9ritage obligatoire !\n    def __init__(self, name: str):\n        self.name = name\n\n    def to_json(self) -&gt; str:\n        return f'{{\"name\": \"{self.name}\"}}'\n\n# \u274c Impossible d'utiliser une classe qu'on ne contr\u00f4le pas\n# (ex: une classe d'une librairie externe qui a d\u00e9j\u00e0 to_json())\n</code></pre>"},{"location":"cours-1-type-hint/#exemple-avec-protocol-typage-structural","title":"Exemple avec Protocol (typage structural)","text":"<pre><code>from typing import Protocol\n\nclass Serializable(Protocol):\n    def to_json(self) -&gt; str: ...\n\n# \u2705 Pas besoin d'h\u00e9riter ! La classe doit juste avoir to_json()\nclass User:  # Pas d'h\u00e9ritage\n    def __init__(self, name: str):\n        self.name = name\n\n    def to_json(self) -&gt; str:\n        return f'{{\"name\": \"{self.name}\"}}'\n\n# \u2705 Fonctionne aussi avec des classes existantes (librairies externes)\nclass ExternalApiResponse:  # Imaginons une classe d'une lib externe\n    def to_json(self) -&gt; str:\n        return '{\"status\": \"ok\"}'\n\ndef save_to_file(obj: Serializable) -&gt; None:\n    with open(\"data.json\", \"w\") as f:\n        f.write(obj.to_json())\n\nsave_to_file(User(\"Alice\"))           # \u2705 OK\nsave_to_file(ExternalApiResponse())   # \u2705 OK aussi !\n</code></pre> <p>\ud83d\udca1 Quand utiliser quoi ? - ABC : Quand tu veux forcer un h\u00e9ritage explicite et fournir des impl\u00e9mentations par d\u00e9faut - Protocol : Quand tu veux de la flexibilit\u00e9 (duck typing v\u00e9rifi\u00e9) et compatibilit\u00e9 avec du code existant</p>"},{"location":"cours-1-type-hint/#le-vrai-pouvoir-de-protocol-la-composition","title":"Le vrai pouvoir de Protocol : la composition","text":"<p>Imaginons qu'une ABC d\u00e9finisse 2 m\u00e9thodes, mais que certaines classes n'en impl\u00e9mentent qu'une seule :</p> <pre><code>from abc import ABC, abstractmethod\n\nclass DataHandler(ABC):\n    @abstractmethod\n    def read(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def write(self, data: str) -&gt; None:\n        pass\n\n# \u274c PROBL\u00c8ME : Database peut lire ET \u00e9crire\nclass Database(DataHandler):\n    def read(self) -&gt; str:\n        return \"data from DB\"\n    def write(self, data: str) -&gt; None:\n        print(f\"Writing {data} to DB\")\n\n# \u274c PROBL\u00c8ME : Logger ne peut QUE \u00e9crire, pas lire !\n# Mais on est OBLIG\u00c9 d'impl\u00e9menter read() quand m\u00eame...\nclass Logger(DataHandler):\n    def read(self) -&gt; str:\n        raise NotImplementedError(\"Logger can't read!\")  # \ud83d\ude2c Hack moche\n    def write(self, data: str) -&gt; None:\n        print(f\"[LOG] {data}\")\n</code></pre> <p>Avec Protocol, on peut d\u00e9finir des contrats s\u00e9par\u00e9s et composables :</p> <pre><code>from typing import Protocol\n\nclass Readable(Protocol):\n    def read(self) -&gt; str: ...\n\nclass Writable(Protocol):\n    def write(self, data: str) -&gt; None: ...\n\n# Database impl\u00e9mente les DEUX\nclass Database:\n    def read(self) -&gt; str:\n        return \"data from DB\"\n    def write(self, data: str) -&gt; None:\n        print(f\"Writing {data} to DB\")\n\n# Logger n'impl\u00e9mente QUE write - et c'est OK !\nclass Logger:\n    def write(self, data: str) -&gt; None:\n        print(f\"[LOG] {data}\")\n\n# \u2705 Fonctions qui demandent SEULEMENT ce dont elles ont besoin\ndef fetch_data(source: Readable) -&gt; str:\n    return source.read()\n\ndef log_message(dest: Writable, msg: str) -&gt; None:\n    dest.write(msg)\n\ndef backup(source: Readable, dest: Writable) -&gt; None:\n    data = source.read()\n    dest.write(data)\n\n# Utilisation\ndb = Database()\nlogger = Logger()\n\nfetch_data(db)           # \u2705 OK : Database a read()\nlog_message(logger, \"Hello\")  # \u2705 OK : Logger a write()\nlog_message(db, \"Hello\")      # \u2705 OK : Database a aussi write()\nbackup(db, logger)       # \u2705 OK : db peut read(), logger peut write()\n# fetch_data(logger)       # \u274c Erreur mypy : Logger n'a pas read()\n</code></pre> <p>\ud83c\udfaf Principe cl\u00e9 : Avec Protocol, chaque fonction demande uniquement les m\u00e9thodes dont elle a besoin. C'est l'Interface Segregation Principle (SOLID) appliqu\u00e9 naturellement !</p>"},{"location":"cours-2-datastructure/","title":"Data structure","text":""},{"location":"cours-2-datastructure/#numerical","title":"Numerical","text":"<p>Il y a les entiers, les flottants et les d\u00e9cimaux qui sont une version plus pr\u00e9cise que les flottants.</p> <p>On peut facilement convertir des flottants en entiers et inversement.</p> <pre><code>x = 3.5\n\nprint(int(x))\n\nx = 3\n\nprint(float(x))\n</code></pre>"},{"location":"cours-2-datastructure/#integer","title":"Integer","text":"<p>Les entiers dans Python ont une taille de repr\u00e9sentation limit\u00e9e uniquement par la m\u00e9moire RAM (contrairement \u00e0 Java ou C# qui ont une taille de repr\u00e9sentation soit de 32 bits soit de 64 bits). Cela permet d'avoir des entiers tr\u00e8s longs et tr\u00e8s pr\u00e9cis, mais la repr\u00e9sentation de ce nombre peut varier en fonction de la RAM disponible entre deux PC si le nombre est extr\u00eamement long.</p> <p>Le fait que les entiers sont limit\u00e9s uniquement par la m\u00e9moire RAM implique que si le nombre est vraiment grand, il peut ralentir le syst\u00e8me et donc la vitesse des op\u00e9rations de calcul.</p> <p>Si le nombre est vraiment tr\u00e8s grand, l'ordinateur pourrait m\u00eame ne plus fonctionner.</p> <p>Exemples:</p> <pre><code># Entiers normaux\nx = 42\ny = -100\nprint(x + y)  # -58\n\n# Python peut g\u00e9rer des entiers tr\u00e8s grands (qui d\u00e9passeraient Java/C#)\n# En Java, le max int est 2,147,483,647 (32 bits)\n# En Java, le max long est 9,223,372,036,854,775,807 (64 bits)\ntres_grand_nombre = 999999999999999999999999999999999999999999999999\nprint(tres_grand_nombre)  # Fonctionne sans probl\u00e8me!\n\n# Op\u00e9rations avec de tr\u00e8s grands nombres\na = 10 ** 100  # 1 suivi de 100 z\u00e9ros\nb = 10 ** 101\nresultat = a * b\nprint(f\"R\u00e9sultat a {len(str(resultat))} chiffres\")\n\n# D\u00e9monstration de l'impact sur la performance\nimport time\n\n# Op\u00e9ration rapide avec de petits nombres\nstart = time.time()\npetit = 1000 ** 10\nend = time.time()\nprint(f\"Petit nombre: {(end - start) * 1000:.4f} ms\")\n\n# Op\u00e9ration plus lente avec de tr\u00e8s grands nombres\nstart = time.time()\ngrand = 1000 ** 1000\nend = time.time()\nprint(f\"Grand nombre: {(end - start) * 1000:.4f} ms\")\n</code></pre>"},{"location":"cours-2-datastructure/#flottant","title":"Flottant","text":"<p>Les flottants ont une pr\u00e9cision fixe, ce qui veut dire qu'\u00e0 partir d'une certaine taille Python va tronquer l'exc\u00e9dent. Cela peut conduire \u00e0 une propagation d'erreurs qui est souvent n\u00e9gligeable pour la majorit\u00e9 des cas d'usage mais catastrophique pour les calculs de haute pr\u00e9cision.</p> <p>Exemples:</p> <pre><code># Op\u00e9rations de base avec les flottants\nx = 3.14\ny = 2.71\nprint(x * y)  # 8.5094\n\n# Probl\u00e8me classique de pr\u00e9cision: 0.1 + 0.2\nresultat = 0.1 + 0.2\nprint(resultat)  # 0.30000000000000004 au lieu de 0.3 !\nprint(resultat == 0.3)  # False - probl\u00e8me pour les comparaisons\n\n# Perte de pr\u00e9cision avec de grands nombres\ngrand_float = 1.0e16  # 10 000 000 000 000 000\npetit_ajout = grand_float + 1.0\nprint(petit_ajout == grand_float)  # True - le +1 est perdu!\n\n# Troncature des d\u00e9cimales\nnombre_long = 1.123456789012345678901234567890\nprint(nombre_long)  # Environ ~15-17 chiffres de pr\u00e9cision seulement\n\n# Propagation d'erreur dans les calculs\n# Exemple: calcul it\u00e9ratif qui accumule les erreurs\nsomme = 0.0\nfor i in range(10):\n    somme += 0.1\nprint(f\"R\u00e9sultat: {somme}\")  # ~0.9999999999999999 au lieu de 1.0\nprint(f\"Erreur: {abs(somme - 1.0)}\")\n\n# Comparaison correcte de flottants avec une tol\u00e9rance\ndef floats_egaux(a, b, tolerance=1e-9):\n    return abs(a - b) &lt; tolerance\n\nprint(floats_egaux(0.1 + 0.2, 0.3))  # True - bonne pratique!\n\n# \u00c9viter les comparaisons directes\na = 0.1 + 0.2\n# Mauvais:\n# if a == 0.3:\n# Bon:\nif abs(a - 0.3) &lt; 1e-9:\n    print(\"Les nombres sont \u00e9gaux (avec tol\u00e9rance)\")\n</code></pre>"},{"location":"cours-2-datastructure/#decimal","title":"Decimal","text":"<p>C'est une solution qui permet d'\u00eatre plus pr\u00e9cis avec les nombres d\u00e9cimaux en les exprimant sous forme de fraction. Les Decimal couvrent la majorit\u00e9 des cas mais en contrepartie sont plus lents que les flottants.</p> <p>Exemples:</p> <pre><code>from decimal import Decimal, getcontext\n\n# Cr\u00e9er des Decimal \u00e0 partir de strings (recommand\u00e9)\n# IMPORTANT: Utiliser des strings, pas des floats!\nprix1 = Decimal('10.50')\nprix2 = Decimal('20.30')\ntotal = prix1 + prix2\nprint(f\"Total: {total}\")  # 30.80 - pr\u00e9cis!\n\n# Comparaison: Float vs Decimal\n# Avec float (impr\u00e9cis):\nfloat_result = 0.1 + 0.2\nprint(f\"Float: {float_result}\")  # 0.30000000000000004\n\n# Avec Decimal (pr\u00e9cis):\ndecimal_result = Decimal('0.1') + Decimal('0.2')\nprint(f\"Decimal: {decimal_result}\")  # 0.3 - exactement!\nprint(decimal_result == Decimal('0.3'))  # True\n\n# Probl\u00e8me: cr\u00e9er Decimal \u00e0 partir de float (\u00e0 \u00e9viter!)\nmauvais_decimal = Decimal(0.1)  # H\u00e9rite l'impr\u00e9cision du float\nprint(f\"Mauvais: {mauvais_decimal}\")  # 0.1000000000000000055511151231257827021181583404541015625\n\nbon_decimal = Decimal('0.1')  # Parfaitement pr\u00e9cis\nprint(f\"Bon: {bon_decimal}\")  # 0.1\n\n# D\u00e9finir la pr\u00e9cision\ngetcontext().prec = 6  # 6 chiffres significatifs\nresult = Decimal('1') / Decimal('3')\nprint(f\"1/3 avec pr\u00e9cision 6: {result}\")  # 0.333333\n\ngetcontext().prec = 28  # Pr\u00e9cision par d\u00e9faut\nresult = Decimal('1') / Decimal('3')\nprint(f\"1/3 avec pr\u00e9cision 28: {result}\")  # Plus de chiffres\n\n# Cas d'usage: calculs financiers\n# Les banques ne peuvent pas tol\u00e9rer les erreurs de pr\u00e9cision!\nmontant = Decimal('100.00')\ntaux_taxe = Decimal('0.20')  # 20%\ntaxe = montant * taux_taxe\ntotal_ttc = montant + taxe\nprint(f\"Montant HT: {montant}\")\nprint(f\"Taxe (20%): {taxe}\")\nprint(f\"Total TTC: {total_ttc}\")  # 120.00\n\n# Arrondir correctement pour l'argent\nfrom decimal import ROUND_HALF_UP\nprix = Decimal('10.555')\nprix_arrondi = prix.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\nprint(f\"Prix arrondi: {prix_arrondi}\")  # 10.56\n</code></pre>"},{"location":"cours-2-datastructure/#string","title":"String","text":"<p>Pour les strings, on peut utiliser des guillemets simples (single quotes) ou des guillemets doubles (double quotes), cela n'a pas vraiment d'importance.</p> <pre><code># Single quote et double quote - identiques\nmessage1 = 'Bonjour'\nmessage2 = \"Bonjour\"\nprint(message1 == message2)  # True\n\n# Utilit\u00e9: inclure des quotes dans la string\ncitation1 = \"Il a dit: 'C'est g\u00e9nial!'\"\ncitation2 = 'Elle a r\u00e9pondu: \"Merci!\"'\nprint(citation1)\nprint(citation2)\n\n# \u00c9chapper les quotes si n\u00e9cessaire\nechappement = 'Il a dit: \\'Bonjour\\''\nprint(echappement)  # Il a dit: 'Bonjour'\n</code></pre> <p>On peut aussi utiliser plusieurs quotes (triple quotes) pour faire du texte multi-ligne.</p> <pre><code># Multiline avec triple quotes (''' ou \"\"\")\ntexte_long = '''\nCeci est un texte\nsur plusieurs lignes.\nLes sauts de ligne sont pr\u00e9serv\u00e9s.\n'''\nprint(texte_long)\n\n# Alternative avec double triple quotes\npoeme = \"\"\"\nRoses are red,\nViolets are blue,\nPython is awesome,\nAnd so are you!\n\"\"\"\nprint(poeme)\n</code></pre> <p>Les strings contiennent plusieurs op\u00e9rations en commun avec les listes (concat\u00e9nation, slicing, index).</p> <p>Exemples:</p> <pre><code>texte = \"Python\"\n\n# Indexing (comme les listes)\nprint(texte[0])    # 'P' - premier caract\u00e8re\nprint(texte[-1])   # 'n' - dernier caract\u00e8re\nprint(texte[2])    # 't' - troisi\u00e8me caract\u00e8re\n\n# Slicing (comme les listes)\nprint(texte[0:3])   # 'Pyt' - du d\u00e9but \u00e0 l'index 3 (exclus)\nprint(texte[2:])    # 'thon' - de l'index 2 jusqu'\u00e0 la fin\nprint(texte[:4])    # 'Pyth' - du d\u00e9but \u00e0 l'index 4 (exclus)\nprint(texte[::2])   # 'Pto' - un caract\u00e8re sur deux\nprint(texte[::-1])  # 'nohtyP' - inversion de la string\n\n# Concat\u00e9nation (comme les listes)\nsalut = \"Bonjour\"\nnom = \"Alice\"\nmessage = salut + \" \" + nom\nprint(message)  # 'Bonjour Alice'\n\n# R\u00e9p\u00e9tition (comme les listes)\nprint(\"Ha\" * 3)  # 'HaHaHa'\nseparateur = \"-\" * 20\nprint(separateur)  # '--------------------'\n\n# Longueur (comme les listes)\nprint(len(\"Python\"))  # 6\n\n# It\u00e9ration (comme les listes)\nfor lettre in \"Python\":\n    print(lettre)  # P, y, t, h, o, n (un par ligne)\n\n# Appartenance (comme les listes)\nprint(\"th\" in \"Python\")      # True\nprint(\"java\" in \"Python\")    # False\nprint(\"P\" not in \"Python\")   # False\n\n# Diff\u00e9rence importante: les strings sont IMMUTABLES!\n# texte[0] = 'J'  # \u274c ERREUR! TypeError\n# Il faut cr\u00e9er une nouvelle string:\nnouveau_texte = 'J' + texte[1:]\nprint(nouveau_texte)  # 'Jython'\n</code></pre> <p>Contrairement aux listes, les strings sont immutables.</p> <p>Exemples:</p> <pre><code># STRING (immutable) - ne peut PAS \u00eatre modifi\u00e9e\ntexte = \"Python\"\n\n# \u274c Tentative de modification -&gt; ERREUR\ntry:\n    texte[0] = 'J'  # TypeError\nexcept TypeError as e:\n    print(f\"Erreur: {e}\")\n\n# \u2705 Pour \"modifier\", on cr\u00e9e une NOUVELLE string\nnouveau_texte = 'J' + texte[1:]\nprint(nouveau_texte)  # 'Jython'\nprint(texte)  # 'Python' - l'original n'a pas chang\u00e9!\n\n# LIST (mutable) - modification directe possible\nlettres = ['P', 'y', 't', 'h', 'o', 'n']\nlettres[0] = 'J'  # \u2705 Fonctionne!\nprint(lettres)  # ['J', 'y', 't', 'h', 'o', 'n']\n\n# Performance: \u00e9viter la concat\u00e9nation r\u00e9p\u00e9t\u00e9e\n# \u274c Lent (cr\u00e9e une nouvelle string \u00e0 chaque it\u00e9ration):\nresultat = \"\"\nfor i in range(1000):\n    resultat += str(i)\n\n# \u2705 Rapide (une seule op\u00e9ration finale):\nmorceaux = [str(i) for i in range(1000)]\nresultat = ''.join(morceaux)\n</code></pre>"},{"location":"cours-2-datastructure/#f-string","title":"F string","text":"<p>Les f-strings (formatted string literals) permettent d'ins\u00e9rer des variables et des expressions directement dans une string en utilisant le pr\u00e9fixe <code>f</code> et des accolades <code>{}</code>. C'est la m\u00e9thode la plus moderne et lisible pour formater des strings en Python (introduite en Python 3.6).</p> <p>Exemples:</p> <pre><code># Interpolation de base\nnom = \"Alice\"\nage = 25\nmessage = f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\"\nprint(message)  # Bonjour, je m'appelle Alice et j'ai 25 ans.\n\n# Expressions dans les f-strings\nx = 10\ny = 5\nprint(f\"{x} + {y} = {x + y}\")  # 10 + 5 = 15\nprint(f\"{x} * {y} = {x * y}\")  # 10 * 5 = 50\n\n# Appeler des m\u00e9thodes\nnom = \"alice\"\nprint(f\"Bonjour {nom.upper()}!\")  # Bonjour ALICE!\nprint(f\"Bonjour {nom.capitalize()}!\")  # Bonjour Alice!\n\n# Formatage de nombres\nprix = 19.99\nprint(f\"Prix: {prix:.2f}\u20ac\")  # Prix: 19.99\u20ac\n\npi = 3.14159265359\nprint(f\"Pi: {pi:.2f}\")  # Pi: 3.14\nprint(f\"Pi: {pi:.5f}\")  # Pi: 3.14159\n\n# Formatage de grands nombres avec s\u00e9parateur\npopulation = 67000000\nprint(f\"Population: {population:,}\")  # Population: 67,000,000\n\n# Alignement et padding\nnom = \"Alice\"\nprint(f\"{nom:&gt;10}\")   # \"     Alice\" - align\u00e9 \u00e0 droite, 10 caract\u00e8res\nprint(f\"{nom:&lt;10}\")   # \"Alice     \" - align\u00e9 \u00e0 gauche\nprint(f\"{nom:^10}\")   # \"  Alice   \" - centr\u00e9\n\n# Afficher des pourcentages\ntaux = 0.157\nprint(f\"Taux: {taux:.1%}\")  # Taux: 15.7%\n\n# Notation scientifique\ngrand_nombre = 1234567890\nprint(f\"{grand_nombre:e}\")  # 1.234568e+09\n\n# Comparaison avec anciennes m\u00e9thodes\n# \u274c Ancienne m\u00e9thode (moins lisible):\nprint(\"Bonjour, je m'appelle %s et j'ai %d ans.\" % (nom, age))\nprint(\"Bonjour, je m'appelle {} et j'ai {} ans.\".format(nom, age))\n\n# \u2705 F-string (moderne et lisible):\nprint(f\"Bonjour, je m'appelle {nom} et j'ai {age} ans.\")\n\n# Debug: afficher variable et valeur (Python 3.8+)\nx = 42\nprint(f\"{x=}\")  # x=42\n</code></pre>"},{"location":"cours-2-datastructure/#booleen","title":"Booleen","text":"<p>Les bool\u00e9ens sont simples : ils ne sont compos\u00e9s que de deux valeurs <code>True</code> et <code>False</code>. Ces deux valeurs ont des \u00e9quivalents entiers <code>1</code> et <code>0</code> car au final <code>True</code> et <code>False</code> sont des sous-classes d'entiers et donc sont des entiers.</p> <p>Exemples:</p> <pre><code># Valeurs bool\u00e9ennes de base\nvrai = True\nfaux = False\nprint(vrai)  # True\nprint(faux)  # False\n\n# \u00c9quivalence avec les entiers\nprint(True == 1)   # True\nprint(False == 0)  # True\nprint(True + True)  # 2 (1 + 1)\nprint(True * 5)     # 5 (1 * 5)\n\n# Conversion bool vers int\nprint(int(True))   # 1\nprint(int(False))  # 0\n\n# Conversion int vers bool\nprint(bool(1))     # True\nprint(bool(0))     # False\nprint(bool(42))    # True (tout nombre non-z\u00e9ro est True)\nprint(bool(-5))    # True\n\n# Op\u00e9rations bool\u00e9ennes\nprint(True and True)    # True\nprint(True and False)   # False\nprint(True or False)    # True\nprint(False or False)   # False\nprint(not True)         # False\nprint(not False)        # True\n\n# Comparaisons retournent des bool\u00e9ens\nprint(5 &gt; 3)      # True\nprint(10 == 10)   # True\nprint(7 &lt; 2)      # False\nprint(\"a\" == \"a\") # True\n\n# Truthiness et Falsiness - autres types \u00e9valu\u00e9s comme bool\n# Falsy (\u00e9valu\u00e9s comme False):\nprint(bool(0))         # False\nprint(bool(\"\"))        # False - string vide\nprint(bool([]))        # False - liste vide\nprint(bool({}))        # False - dict vide\nprint(bool(None))      # False\n\n# Truthy (\u00e9valu\u00e9s comme True):\nprint(bool(1))         # True\nprint(bool(\"texte\"))   # True - string non-vide\nprint(bool([1, 2]))    # True - liste non-vide\nprint(bool({\"a\": 1}))  # True - dict non-vide\n\n# Utilisation dans les conditions\nage = 18\nif age &gt;= 18:\n    print(\"Majeur\")  # S'ex\u00e9cute car True\nelse:\n    print(\"Mineur\")\n\n# Court-circuit (short-circuit evaluation)\ndef fonction_lente():\n    print(\"Fonction appel\u00e9e\")\n    return True\n\n# and: si le premier est False, le second n'est pas \u00e9valu\u00e9\nresult = False and fonction_lente()  # fonction_lente() n'est PAS appel\u00e9e\nprint(result)  # False\n\n# or: si le premier est True, le second n'est pas \u00e9valu\u00e9\nresult = True or fonction_lente()  # fonction_lente() n'est PAS appel\u00e9e\nprint(result)  # True\n</code></pre>"},{"location":"cours-2-datastructure/#enum","title":"Enum","text":"<p>Les Enums (\u00e9num\u00e9rations) permettent de cr\u00e9er des ensembles de constantes nomm\u00e9es. Elles rendent le code plus lisible et moins sujet aux erreurs qu'avec des constantes simples ou des strings magiques.</p> <p>Exemples:</p> <pre><code>from enum import Enum, auto, IntEnum, StrEnum\n\n# Enum de base\nclass Couleur(Enum):\n    ROUGE = 1\n    VERT = 2\n    BLEU = 3\n\n# Acc\u00e9der aux membres\nprint(Couleur.ROUGE)        # Couleur.ROUGE\nprint(Couleur.ROUGE.name)   # 'ROUGE'\nprint(Couleur.ROUGE.value)  # 1\n\n# Comparaison\nfavori = Couleur.BLEU\nif favori == Couleur.BLEU:\n    print(\"C'est bleu!\")  # S'ex\u00e9cute\n\n# \u274c Comparaison par valeur ne fonctionne pas!\nprint(Couleur.ROUGE == 1)  # False\n\n# It\u00e9ration\nprint(\"Toutes les couleurs:\")\nfor couleur in Couleur:\n    print(f\"{couleur.name} = {couleur.value}\")\n\n# ---\n\n# auto() - g\u00e9n\u00e9ration automatique de valeurs\nclass Statut(Enum):\n    EN_ATTENTE = auto()   # 1\n    EN_COURS = auto()     # 2\n    TERMINE = auto()      # 3\n    ANNULE = auto()       # 4\n\nprint(Statut.EN_COURS.value)  # 2\n\n# ---\n\n# StrEnum - Enum bas\u00e9 sur des strings (Python 3.11+)\nclass Environnement(StrEnum):\n    DEV = \"development\"\n    STAGING = \"staging\"\n    PROD = \"production\"\n\n# Avec StrEnum, on peut comparer directement avec des strings\nenv = Environnement.PROD\nprint(env == \"production\")  # True\nprint(env)  # 'production' (pas Environnement.PROD)\n\n# Utile pour les configurations\nconfig_env = \"production\"\nif config_env == Environnement.PROD:\n    print(\"Mode production!\")  # S'ex\u00e9cute\n\n# ---\n\n# StrEnum avec auto() - g\u00e9n\u00e8re automatiquement les valeurs\nclass Direction(StrEnum):\n    HAUT = auto()     # 'haut'\n    BAS = auto()      # 'bas'\n    GAUCHE = auto()   # 'gauche'\n    DROITE = auto()   # 'droite'\n\nprint(Direction.HAUT)        # 'haut'\nprint(Direction.HAUT.value)  # 'haut'\n\n# ---\n\n# IntEnum - Enum compatible avec les entiers\nclass Code(IntEnum):\n    SUCCES = 200\n    NON_TROUVE = 404\n    ERREUR_SERVEUR = 500\n\n# IntEnum peut \u00eatre utilis\u00e9 comme un entier\ncode = Code.SUCCES\nprint(code == 200)  # True\nprint(code + 1)     # 201\n\n# ---\n\n# Cas d'usage r\u00e9el: remplacer les \"magic strings\"\n# \u274c Mauvais (strings magiques, sujets aux typos):\ndef traiter_commande(statut):\n    if statut == \"en_cours\":  # Typo possible!\n        print(\"Traitement...\")\n\ntraiter_commande(\"en cours\")  # Bug silencieux!\n\n# \u2705 Bon (avec Enum):\nclass StatutCommande(StrEnum):\n    EN_ATTENTE = auto()\n    EN_COURS = auto()\n    TERMINE = auto()\n\ndef traiter_commande_safe(statut: StatutCommande):\n    if statut == StatutCommande.EN_COURS:\n        print(\"Traitement...\")\n\ntraiter_commande_safe(StatutCommande.EN_COURS)  # Type-safe!\n</code></pre>"},{"location":"cours-2-datastructure/#list","title":"List","text":"<p>Les listes sont des s\u00e9quences mutables et ordonn\u00e9es d'\u00e9l\u00e9ments. Pour faire simple, chaque \u00e9l\u00e9ment peut \u00eatre modifi\u00e9 et poss\u00e8de un index fixe. Les \u00e9l\u00e9ments d'une liste ne sont pas oblig\u00e9s d'\u00eatre du m\u00eame type et la taille maximale d'une liste d\u00e9pend uniquement de la taille de la RAM, donc potentiellement infinie.</p> <p>Les listes se redimensionnent automatiquement et peuvent donc conduire \u00e0 des probl\u00e8mes de m\u00e9moire. Si les \u00e9l\u00e9ments sont trop diff\u00e9rents, les op\u00e9rations sur les diff\u00e9rents \u00e9l\u00e9ments peuvent devenir complexes. Si on a besoin d'une structure avec beaucoup de types de donn\u00e9es diff\u00e9rentes, les classes sont mieux adapt\u00e9es.</p> <p>Les recherches dans une liste peuvent \u00eatre longues ; pour des recherches tr\u00e8s fr\u00e9quentes, les dictionnaires sont plus adapt\u00e9s.</p> <p>Exemples:</p> <pre><code># Cr\u00e9ation de listes\nliste_vide = []\nliste_nombres = [1, 22, 9, 5, 100]\nliste_mixte = [1, \"texte\", 3.14, True]  # Types diff\u00e9rents possibles\n\nprint(type([]))  # &lt;class 'list'&gt;\n\n# Acc\u00e8s et modification (mutable)\nliste_nombres[0] = 999\nprint(liste_nombres)  # [999, 22, 9, 5, 100]\n\n# M\u00e9thodes principales\nliste_nombres.append(200)  # Ajouter \u00e0 la fin\nprint(liste_nombres)  # [999, 22, 9, 5, 100, 200]\n\nliste_nombres.insert(0, 10)  # Ins\u00e9rer \u00e0 l'index 0\nprint(liste_nombres)  # [10, 999, 22, 9, 5, 100, 200]\n\nliste_nombres.remove(999)  # Retirer la premi\u00e8re occurrence\nprint(liste_nombres)  # [10, 22, 9, 5, 100, 200]\n\ndernier = liste_nombres.pop()  # Retirer et retourner le dernier\nprint(dernier)  # 200\n\n# Tri\nliste_nombres.sort()  # Trier en place\nprint(liste_nombres)  # [5, 9, 10, 22, 100]\n\nliste_nombres.reverse()  # Inverser en place\nprint(liste_nombres)  # [100, 22, 10, 9, 5]\n\n# Longueur\nprint(len(liste_nombres))  # 5\n\n# Slicing\nprint(liste_nombres[1:3])  # [22, 10]\nprint(liste_nombres[:2])   # [100, 22]\n\n# List comprehension (cr\u00e9ation rapide)\ncarres = [x**2 for x in range(5)]\nprint(carres)  # [0, 1, 4, 9, 16]\n\n# Recherche (O(n) - peut \u00eatre lent)\nif 22 in liste_nombres:\n    print(\"22 trouv\u00e9!\")\n\nindex = liste_nombres.index(22)  # Trouver l'index\nprint(f\"22 est \u00e0 l'index {index}\")  # 22 est \u00e0 l'index 1\n</code></pre>"},{"location":"cours-2-datastructure/#array","title":"Array","text":"<p>Les arrays sont moins flexibles et plus basiques que les listes. Elles ont une taille fixe ce qui permet un acc\u00e8s bien plus rapide aux \u00e9l\u00e9ments car une m\u00e9moire leur est allou\u00e9e. On utilise souvent NumPy pour les arrays.</p> <p>Exemples:</p> <pre><code>from array import array\nimport numpy as np\n\n# Array Python standard (un seul type)\narr = array('i', [1, 2, 3, 4, 5])  # 'i' = entiers sign\u00e9s\nprint(arr)  # array('i', [1, 2, 3, 4, 5])\n\n# Modification\narr[0] = 10\nprint(arr)  # array('i', [10, 2, 3, 4, 5])\n\n# \u274c Tous les \u00e9l\u00e9ments doivent \u00eatre du m\u00eame type\n# arr.append(3.14)  # TypeError!\n\n# NumPy arrays (plus puissants et populaires)\nnp_arr = np.array([1, 2, 3, 4, 5])\nprint(np_arr)  # [1 2 3 4 5]\n\n# Op\u00e9rations vectoris\u00e9es (tr\u00e8s rapides!)\nprint(np_arr * 2)  # [ 2  4  6  8 10]\nprint(np_arr + 10)  # [11 12 13 14 15]\n\n# Op\u00e9rations math\u00e9matiques\nprint(np_arr.mean())  # 3.0\nprint(np_arr.sum())   # 15\nprint(np_arr.max())   # 5\n\n# Arrays multidimensionnels\nmatrice = np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrice)\nprint(matrice.shape)  # (2, 3)\n</code></pre>"},{"location":"cours-2-datastructure/#dictionary","title":"Dictionary","text":"<p>Pour la recherche, rien n'est plus rapide que les dictionnaires car ils utilisent une table de hachage (hash table).</p> <p>Les dictionnaires sont ordonn\u00e9s depuis Python 3.7+ (ordre d'insertion) et ont besoin de plus de m\u00e9moire.</p> <p>Exemples:</p> <pre><code># Cr\u00e9ation de dictionnaires\ndict_vide = {}\npersonne = {\n    \"nom\": \"Dupont\",\n    \"prenom\": \"Jean\",\n    \"age\": 30\n}\n\n# Acc\u00e8s (O(1) - tr\u00e8s rapide!)\nprint(personne[\"nom\"])  # Dupont\nprint(personne.get(\"age\"))  # 30\nprint(personne.get(\"ville\", \"Paris\"))  # Paris (d\u00e9faut si cl\u00e9 absente)\n\n# Modification et ajout\npersonne[\"age\"] = 31  # Modifier\npersonne[\"ville\"] = \"Lyon\"  # Ajouter nouvelle cl\u00e9\nprint(personne)\n\n# Suppression\ndel personne[\"ville\"]\nage = personne.pop(\"age\")  # Retirer et retourner\nprint(age)  # 31\n\n# V\u00e9rifier l'existence d'une cl\u00e9 (O(1) - tr\u00e8s rapide!)\nif \"nom\" in personne:\n    print(\"Nom pr\u00e9sent!\")\n\n# It\u00e9ration\nfor cle, valeur in personne.items():\n    print(f\"{cle}: {valeur}\")\n\n# M\u00e9thodes utiles\nprint(personne.keys())    # dict_keys(['nom', 'prenom'])\nprint(personne.values())  # dict_values(['Dupont', 'Jean'])\n\n# Dict comprehension\ncarres = {x: x**2 for x in range(5)}\nprint(carres)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# Fusion de dictionnaires (Python 3.9+)\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"c\": 3, \"d\": 4}\nfusion = dict1 | dict2\nprint(fusion)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n\n# Comptage rapide avec get()\nmots = [\"chat\", \"chien\", \"chat\", \"oiseau\", \"chat\"]\ncompteur = {}\nfor mot in mots:\n    compteur[mot] = compteur.get(mot, 0) + 1\nprint(compteur)  # {'chat': 3, 'chien': 1, 'oiseau': 1}\n</code></pre>"},{"location":"cours-2-datastructure/#tuple","title":"Tuple","text":"<p>Les tuples sont des collections d'objets immuables. Compar\u00e9s aux listes, ils ont un acc\u00e8s bien plus rapide aux \u00e9l\u00e9ments. Ils sont beaucoup utilis\u00e9s pour le packing et l'unpacking de variables. Ils peuvent aussi \u00eatre utilis\u00e9s pour des match/case avec des valeurs complexes. Cependant, si la structure devient trop complexe, il faudra migrer vers une classe.</p> <p>Exemples:</p> <pre><code># Cr\u00e9ation de tuples\ntuple_vide = ()\ncoordonnees = (10, 20)\npersonne = (\"Jean\", \"Dupont\", 30)\ntuple_un_element = (42,)  # Virgule obligatoire!\n\n# Acc\u00e8s (comme les listes)\nprint(coordonnees[0])  # 10\nprint(personne[1])     # Dupont\n\n# \u274c Immutable - ne peut pas \u00eatre modifi\u00e9\n# coordonnees[0] = 15  # TypeError!\n\n# Unpacking (d\u00e9ballage)\nx, y = coordonnees\nprint(f\"x={x}, y={y}\")  # x=10, y=20\n\nprenom, nom, age = personne\nprint(f\"{prenom} {nom}, {age} ans\")\n\n# Packing (emballage)\npoint = 5, 10  # Les parenth\u00e8ses sont optionnelles\nprint(point)  # (5, 10)\n\n# \u00c9change de variables (gr\u00e2ce au unpacking)\na, b = 1, 2\na, b = b, a  # \u00c9change!\nprint(f\"a={a}, b={b}\")  # a=2, b=1\n\n# Fonction retournant plusieurs valeurs\ndef get_min_max(nombres):\n    return min(nombres), max(nombres)\n\nminimum, maximum = get_min_max([1, 5, 3, 9, 2])\nprint(f\"Min: {minimum}, Max: {maximum}\")  # Min: 1, Max: 9\n\n# Tuple comme cl\u00e9 de dictionnaire (car immutable)\npositions = {}\npositions[(0, 0)] = \"Origine\"\npositions[(1, 2)] = \"Point A\"\nprint(positions[(0, 0)])  # Origine\n\n# Unpacking \u00e9tendu (Python 3+)\npremier, *milieu, dernier = (1, 2, 3, 4, 5)\nprint(premier)  # 1\nprint(milieu)   # [2, 3, 4]\nprint(dernier)  # 5\n\n# Named tuples (pour plus de lisibilit\u00e9)\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\nprint(p.x, p.y)  # 10 20\nprint(p[0], p[1])  # 10 20 - acc\u00e8s par index aussi\n</code></pre>"},{"location":"cours-2-datastructure/#set","title":"Set","text":"<p>Les sets permettent d'avoir une collection d'\u00e9l\u00e9ments uniques. Ils sont mutables et non ordonn\u00e9s. Ils sont facilement convertibles et peuvent donc servir d'outil de d\u00e9doublonnage avant d'\u00eatre r\u00e9utilis\u00e9s.</p> <p>Si on a besoin d'un set immutable, on peut utiliser des frozensets.</p> <p>Exemples:</p> <pre><code># Cr\u00e9ation de sets\nset_vide = set()  # \u274c PAS {} car c'est un dict!\nnombres = {1, 2, 3, 4, 5}\nlettres = set(['a', 'b', 'c', 'a', 'b'])  # Doublons automatiquement retir\u00e9s\nprint(lettres)  # {'a', 'b', 'c'}\n\n# D\u00e9doublonnage rapide\nliste_avec_doublons = [1, 2, 2, 3, 3, 3, 4]\nliste_unique = list(set(liste_avec_doublons))\nprint(liste_unique)  # [1, 2, 3, 4] (ordre peut varier)\n\n# Ajout et suppression\nnombres.add(6)  # Ajouter\nprint(nombres)  # {1, 2, 3, 4, 5, 6}\n\nnombres.remove(3)  # Retirer (erreur si absent)\nnombres.discard(10)  # Retirer (pas d'erreur si absent)\n\n# Appartenance (O(1) - tr\u00e8s rapide!)\nif 5 in nombres:\n    print(\"5 est pr\u00e9sent\")\n\n# Op\u00e9rations ensemblistes\nset1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\n\n# Union (tous les \u00e9l\u00e9ments)\nprint(set1 | set2)  # {1, 2, 3, 4, 5, 6}\nprint(set1.union(set2))  # \u00c9quivalent\n\n# Intersection (\u00e9l\u00e9ments communs)\nprint(set1 &amp; set2)  # {3, 4}\nprint(set1.intersection(set2))  # \u00c9quivalent\n\n# Diff\u00e9rence (dans set1 mais pas set2)\nprint(set1 - set2)  # {1, 2}\nprint(set1.difference(set2))  # \u00c9quivalent\n\n# Diff\u00e9rence sym\u00e9trique (dans l'un ou l'autre, pas les deux)\nprint(set1 ^ set2)  # {1, 2, 5, 6}\n\n# Sous-ensemble et sur-ensemble\nset_petit = {1, 2}\nprint(set_petit.issubset(set1))  # True\nprint(set1.issuperset(set_petit))  # True\n\n# Frozenset (immutable)\nfs = frozenset([1, 2, 3])\n# fs.add(4)  # \u274c AttributeError - immutable!\n\n# Frozenset peut \u00eatre cl\u00e9 de dictionnaire\nsets_dict = {\n    frozenset([1, 2]): \"Ensemble A\",\n    frozenset([3, 4]): \"Ensemble B\"\n}\nprint(sets_dict[frozenset([1, 2])])  # Ensemble A\n\n# Cas d'usage: filtrer doublons tout en gardant ordre\ndef unique_ordered(items):\n    seen = set()\n    result = []\n    for item in items:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n\nliste = [1, 2, 2, 3, 1, 4, 3, 5]\nprint(unique_ordered(liste))  # [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"cours-3-class-et-dataclass/","title":"Class et Dataclass","text":""},{"location":"cours-3-class-et-dataclass/#introduction","title":"Introduction","text":"<p>Une classe est un blueprint d'un objet. Elle sp\u00e9cifie ce qu'il se passe quand on cr\u00e9e un objet, comment on acc\u00e8de \u00e0 ses parties et quels comportements il poss\u00e8de.</p> <p>Dans Python, tout est un objet. Les fonctions, par exemple, sont des callable.</p> <p>Les classes sont plus concentr\u00e9es sur les behaviors (m\u00e9thodes) plut\u00f4t que sur les donn\u00e9es (attributs). Les dataclasses, c'est le contraire.</p>"},{"location":"cours-3-class-et-dataclass/#les-classes-et-les-methodes-dunder","title":"Les classes et les m\u00e9thodes dunder","text":"<pre><code>class BankAccount:\n    def __init__(self, account_holder: str, balance: int = 0):\n        self.account_holder = account_holder\n        self.balance = balance\n\n    def deposit(self, amount: int):\n        self.balance += amount\n\n    def withdraw(self, amount: int):\n        if amount &lt;= self.balance:\n            self.balance -= amount\n            return True\n        else:\n            return False\n\n    # Comparison based on account balance\n    def __lt__(self, other: \"BankAccount\") -&gt; bool:\n        return self.balance &lt; other.balance\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, BankAccount):\n            raise NotImplementedError\n        return self.balance == other.balance\n\n\ndef main() -&gt; None:\n    account1 = BankAccount(\"Alice\", 1000)\n    account2 = BankAccount(\"Bob\", 1500)\n\n    print(account1 &lt; account2)  # True, because Alice's balance is lower\n    print(account1 == account2)  # False, because the balances are different\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>On peut ajouter de plus en plus de m\u00e9thodes et faire d'elle une \"God\" classe, ce qui est \u00e0 \u00e9viter. Ici, une bonne id\u00e9e serait de s\u00e9parer les donn\u00e9es des m\u00e9thodes.</p> <p>En g\u00e9n\u00e9ral, les classes sont particuli\u00e8rement utiles pour repr\u00e9senter une sorte de donn\u00e9es structur\u00e9es plut\u00f4t qu'un ensemble de m\u00e9thodes.</p>"},{"location":"cours-3-class-et-dataclass/#les-dataclasses","title":"Les dataclasses","text":"<p>La force des dataclasses, c'est qu'elles ont moins de boilerplate code, en particulier dans l'initialisateur. Comme on peut le voir, les dataclasses sont bien plus faciles \u00e0 lire et on peut les appliquer directement :</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass BankAccount:\n    account_holder: str\n    balance: int = 0\n\n    def deposit(self, amount: int):\n        self.balance += amount\n\n    def withdraw(self, amount: int):\n        if amount &lt;= self.balance:\n            self.balance -= amount\n            return True\n        else:\n            return False\n\n    # Comparison based on account balance\n    def __lt__(self, other: \"BankAccount\") -&gt; bool:\n        return self.balance &lt; other.balance\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, BankAccount):\n            raise NotImplementedError\n        return self.balance == other.balance\n\n\ndef main() -&gt; None:\n    account1 = BankAccount(\"Alice\", 1000)\n    account2 = BankAccount(\"Bob\", 1500)\n\n    print(account1 &lt; account2)  # True, because Alice's balance is lower\n    print(account1 == account2)  # False, because the balances are different\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#__repr__-natif","title":"<code>__repr__</code> natif","text":"<p>Les dataclasses ont aussi nativement plusieurs m\u00e9thodes dunder pr\u00e9par\u00e9es, comme <code>__repr__</code> pour <code>print</code> :</p> <pre><code>from dataclasses import dataclass\nfrom enum import StrEnum, auto\n\n\nclass FuelType(StrEnum):\n    PETROL = auto()\n    DIESEL = auto()\n    ELECTRIC = auto()\n\n\n@dataclass\nclass Vehicle:\n    brand: str\n    model: str\n    color: str\n    license_plate: str\n    driving_miles: int = 0\n    fuel_type: FuelType = FuelType.ELECTRIC\n\n    def needs_maintenance(self, maintenance_miles: int = 10000) -&gt; bool:\n        return self.driving_miles &gt;= maintenance_miles\n\n\ndef main() -&gt; None:\n    tesla = Vehicle(\n        brand=\"Tesla\",\n        model=\"Model 3\",\n        color=\"black\",\n        license_plate=\"ABC-123\",\n    )\n    volkswagen = Vehicle(\n        brand=\"Volkswagen\",\n        model=\"ID3\",\n        color=\"white\",\n        license_plate=\"DEF-456\",\n    )\n    bmw = Vehicle(\n        brand=\"BMW\",\n        model=\"520e\",\n        color=\"blue\",\n        license_plate=\"GHI-789\",\n        fuel_type=FuelType.PETROL,\n    )\n\n    print(tesla)\n    print(volkswagen)\n    print(bmw)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#comparaison-des-methodes-dunder","title":"Comparaison des m\u00e9thodes dunder","text":"<p>On peut aller encore plus loin dans la comparaison des m\u00e9thodes dunder entre une classe classique et une dataclass :</p> <pre><code>from dataclasses import dataclass\n\n\n# Class without dataclass\nclass Person:\n    def __init__(self, name: str, age: int):\n        self.name: str = name\n        self.age: int = age\n\n    def __repr__(self):\n        return f\"Person(name={self.name}, age={self.age})\"\n\n    def __eq__(self, other: object):\n        if not isinstance(other, Person):\n            return False\n        return self.name == other.name and self.age == other.age\n\n    def __ne__(self, other: object):\n        if not isinstance(other, Person):\n            return False\n        return self.name != other.name or self.age != other.age\n\n\n# Class with dataclass\n@dataclass\nclass PersonDataclass:\n    name: str\n    age: int\n\n\ndef main() -&gt; None:\n    person1 = Person(\"Alice\", 30)\n    person2 = Person(\"Bob\", 25)\n\n    person_dataclass1 = PersonDataclass(\"Alice\", 30)\n    person_dataclass2 = PersonDataclass(\"Bob\", 25)\n\n    # Check if instances are equal\n    print(person1 == person2)  # Output: False\n    print(person_dataclass1 == person_dataclass2)  # Output: False\n\n    print(person1 != person2)  # Output: True\n    print(person_dataclass1 != person_dataclass2)  # Output: True\n\n    # String representation of instances\n    print(repr(person1))  # Output: Person(name=Alice, age=30)\n    print(repr(person_dataclass1))  # Output: PersonDataclass(name='Alice', age=30)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#ordertrue","title":"<code>order=True</code>","text":"<p>Avec <code>order=True</code>, on ajoute automatiquement les m\u00e9thodes de comparaison (<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code>) :</p> <pre><code>from dataclasses import dataclass\n\n\n# Equivalent class using dataclass\n@dataclass(order=True)\nclass PersonDataclass:\n    name: str\n    age: int\n\n\n# Class without dataclass\nclass Person:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    def __repr__(self):\n        return f\"Person(name={self.name}, age={self.age})\"\n\n    def __eq__(self, other: object):\n        if not isinstance(other, Person):\n            return False\n        return self.name == other.name and self.age == other.age\n\n    def __ne__(self, other: object):\n        if not isinstance(other, Person):\n            return False\n        return not self.__eq__(other)\n\n    def __lt__(self, other: \"Person\"):\n        return self.age &lt; other.age\n\n    def __le__(self, other: \"Person\"):\n        return self.age &lt;= other.age\n\n    def __gt__(self, other: \"Person\"):\n        return self.age &gt; other.age\n\n    def __ge__(self, other: \"Person\"):\n        return self.age &gt;= other.age\n\n\ndef main() -&gt; None:\n    # Create instances of both classes\n    person1 = Person(\"Alice\", 30)\n    person2 = Person(\"Bob\", 25)\n\n    person_dataclass1 = PersonDataclass(\"Alice\", 30)\n    person_dataclass2 = PersonDataclass(\"Bob\", 25)\n\n    # Check if instances are equal\n    print(person1 == person2)  # Output: False\n    print(person_dataclass1 == person_dataclass2)  # Output: False\n\n    print(person1 != person2)  # Output: True\n    print(person_dataclass1 != person_dataclass2)  # Output: True\n\n    # Compare instances based on age\n    print(person1 &lt; person2)  # Output: False\n    print(person_dataclass1 &lt; person_dataclass2)  # Output: False\n\n    print(person1 &lt;= person2)  # Output: False\n    print(person_dataclass1 &lt;= person_dataclass2)  # Output: False\n\n    print(person1 &gt; person2)  # Output: True\n    print(person_dataclass1 &gt; person_dataclass2)  # Output: True\n\n    print(person1 &gt;= person2)  # Output: True\n    print(person_dataclass1 &gt;= person_dataclass2)  # Output: True\n\n    # String representation of instances\n    print(repr(person1))  # Output: Person(name=Alice, age=30)\n    print(repr(person_dataclass1))  # Output: PersonDataclass(name='Alice', age=30)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#fonctionnalites-avancees","title":"Fonctionnalit\u00e9s avanc\u00e9es","text":""},{"location":"cours-3-class-et-dataclass/#default_factory","title":"<code>default_factory</code>","text":"<p>Il est possible d'utiliser <code>default_factory</code> qui permet d'initialiser une liste (ou tout autre objet mutable) sans que les objets pointent sur la m\u00eame r\u00e9f\u00e9rence, vu que Python fonctionne par r\u00e9f\u00e9rence. Pydantic g\u00e8re cela nativement.</p> <p><code>default_factory</code> ne marche pas que pour les listes, mais pour tous les types mutables (dict, set, etc.) :</p> <pre><code>from dataclasses import dataclass, field\nfrom enum import StrEnum, auto\n\n\nclass ConnectivityStatus(StrEnum):\n    ONLINE = auto()\n    OFFLINE = auto()\n    LIMITED = \"Limited Connectivity\"\n\n\n@dataclass\nclass IoTDevice:\n    name: str\n    device_type: str\n    connectivity: ConnectivityStatus\n    sensors: list[str] = field(default_factory=list)\n    location: str = \"Unknown\"\n    firmware_version: int = 1\n\n    def add_sensor(self, sensor_name: str):\n        \"\"\"Add a new sensor to the device.\"\"\"\n        self.sensors.append(sensor_name)\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#options-de-field-et-__post_init__","title":"Options de <code>field()</code> et <code>__post_init__</code>","text":"<p>Les dataclasses peuvent aussi ajouter plusieurs autres fonctionnalit\u00e9s nativement ou les enlever gr\u00e2ce aux options de <code>field()</code> (<code>compare</code>, <code>init</code>, <code>repr</code>) et \u00e0 la m\u00e9thode <code>__post_init__</code> :</p> <pre><code>from dataclasses import dataclass, field\nfrom enum import StrEnum, auto\n\n\nclass DeviceType(StrEnum):\n    LIGHT = auto()\n    THERMOSTAT = auto()\n    SPEAKER = \"Smart Speaker\"\n    SECURITY_CAMERA = auto()\n\n\nclass DeviceStatus(StrEnum):\n    ACTIVE = auto()\n    INACTIVE = auto()\n\n\n@dataclass\nclass DeviceConfig:\n    configuration: dict[str, str] = field(default_factory=dict)\n\n    def update_config(self, key: str, value: str):\n        \"\"\"Update or add a configuration setting for the device.\"\"\"\n        self.configuration[key] = value\n\n\n@dataclass\nclass IoTDevice:\n    name: str\n    device_type: DeviceType\n    status: DeviceStatus\n    config: DeviceConfig = field(default_factory=DeviceConfig, compare=False)\n    firmware_version: int = field(default=1, init=False, repr=False, compare=False)\n\n    def __post_init__(self):\n        \"\"\"Post-initialization to set dynamic defaults.\"\"\"\n        if self.device_type in [DeviceType.LIGHT, DeviceType.SPEAKER]:\n            self.status = DeviceStatus.ACTIVE\n        if self.device_type == DeviceType.THERMOSTAT:\n            self.firmware_version = 2\n\n    def activate(self):\n        if self.status != DeviceStatus.ACTIVE:\n            self.status = DeviceStatus.ACTIVE\n            print(f\"{self.name} activated.\")\n        else:\n            print(f\"{self.name} is already active.\")\n\n    def deactivate(self):\n        if self.status != DeviceStatus.INACTIVE:\n            self.status = DeviceStatus.INACTIVE\n            print(f\"{self.name} deactivated.\")\n        else:\n            print(f\"{self.name} is already inactive.\")\n\n\n@dataclass\nclass SmartHome:\n    devices: list[IoTDevice] = field(default_factory=list)\n\n    def add_device(self, device: IoTDevice) -&gt; IoTDevice:\n        \"\"\"Add a new IoT device to the smart home system.\"\"\"\n        self.devices.append(device)\n        print(f\"Added {device.name} to the smart home system.\")\n        return device\n\n    def get_devices(self):\n        return self.devices\n\n\ndef main() -&gt; None:\n    smart_home = SmartHome()\n\n    light_config = DeviceConfig(configuration={\"brightness\": \"50%\"})\n    light_config_2 = DeviceConfig(configuration={\"brightness\": \"20%\"})\n\n    light = smart_home.add_device(\n        IoTDevice(\n            name=\"Living Room Light\",\n            device_type=DeviceType.LIGHT,\n            status=DeviceStatus.INACTIVE,\n            config=light_config,\n        )\n    )\n\n    smart_home.add_device(\n        IoTDevice(\n            name=\"Door Security Camera\",\n            device_type=DeviceType.SECURITY_CAMERA,\n            status=DeviceStatus.INACTIVE,\n        )\n    )\n\n    smart_home.add_device(\n        IoTDevice(\n            name=\"Smart Thermostat\",\n            device_type=DeviceType.THERMOSTAT,\n            status=DeviceStatus.INACTIVE,\n        )\n    )\n\n    light_2 = smart_home.add_device(\n        IoTDevice(\n            name=\"Living Room Light\",\n            device_type=DeviceType.LIGHT,\n            status=DeviceStatus.INACTIVE,\n            config=light_config_2,\n        )\n    )\n\n    print(light == light_2)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#frozentrue","title":"<code>frozen=True</code>","text":"<p>On peut \u00e9galement ajouter <code>frozen=True</code> pour rendre les attributs immuables. Toute tentative de modification l\u00e8vera une <code>FrozenInstanceError</code> :</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n\n@dataclass(frozen=True)\nclass FinancialTransaction:\n    transaction_id: str\n    amount: int\n    currency: str\n    transaction_date: datetime\n    description: Optional[str] = None\n\n\ndef main() -&gt; None:\n    transaction = FinancialTransaction(\n        transaction_id=\"TXN12345\",\n        amount=999,\n        currency=\"USD\",\n        transaction_date=datetime.now(),\n        description=\"Payment for services rendered\",\n    )\n\n    transaction.amount = 1000  # Raises a TypeError because the class is frozen\n\n    print(transaction)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#slotstrue","title":"<code>slots=True</code>","text":"<p>Si on a besoin de plus de performance, on peut utiliser <code>slots=True</code>. C'est une optimisation de Python : une dataclass est finalement un dictionnaire (accessible via <code>__dict__</code>). Quand on utilise <code>slots</code>, on dit \u00e0 Python de n'allouer de l'espace m\u00e9moire uniquement pour les attributs d\u00e9finis, sans utiliser de dictionnaire interne :</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Self\n\n\n@dataclass(slots=True)\nclass Point:\n    x: int\n    y: int\n    neighbors: list[Self] = field(default_factory=list[Self])\n\n\ndef main() -&gt; None:\n    point = Point(10, 20, [Point(10, 20), Point(20, 30)])\n\n    print(point)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>La principale faiblesse de <code>slots</code> est qu'on ne peut pas allouer de variables dynamiquement.</p>"},{"location":"cours-3-class-et-dataclass/#alternatives-pydantic","title":"Alternatives : Pydantic","text":"<p>Il existe des alternatives comme Pydantic qui permet de faire des validations et de s'int\u00e9grer facilement \u00e0 des APIs modernes comme FastAPI. Il faut par contre faire attention : Pydantic est une d\u00e9pendance externe et prend plus de temps que les classes ou les dataclasses \u00e0 s'initialiser. Si on construit un module de bas niveau (comme de l'open source) et qu'il y a des crit\u00e8res de vitesse, il n'est pas souhaitable de l'utiliser.</p>"},{"location":"cours-3-class-et-dataclass/#validation-et-coercion-de-types","title":"Validation et coercion de types","text":"<p>Pydantic valide automatiquement les types et permet de d\u00e9finir des contraintes via <code>Field</code> (<code>min_length</code>, <code>gt</code>, <code>lt</code>, etc.). Il effectue aussi de la coercion de types (par exemple, convertir <code>\"25\"</code> en <code>25</code>) :</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(min_length=2, max_length=50)\n    age: int = Field(gt=0, lt=150)\n    email: str\n\n\ndef main() -&gt; None:\n    # Pydantic valide automatiquement les types et les contraintes\n    user = User(name=\"Alice\", age=30, email=\"alice@example.com\")\n    print(user)\n\n    # Pydantic convertit automatiquement les types compatibles (coercion)\n    user_coerced = User(name=\"Bob\", age=\"25\", email=\"bob@example.com\")  # \"25\" -&gt; 25\n    print(user_coerced)\n    print(type(user_coerced.age))  # &lt;class 'int'&gt;\n\n    # Validation \u00e9chou\u00e9e : age n\u00e9gatif\n    try:\n        User(name=\"Charlie\", age=-5, email=\"charlie@example.com\")\n    except Exception as e:\n        print(f\"Erreur de validation : {e}\")\n\n    # Validation \u00e9chou\u00e9e : nom trop court\n    try:\n        User(name=\"A\", age=30, email=\"a@example.com\")\n    except Exception as e:\n        print(f\"Erreur de validation : {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#validators-personnalises","title":"Validators personnalis\u00e9s","text":"<p>Avec <code>@field_validator</code>, on peut transformer et valider chaque champ individuellement. Avec <code>@model_validator</code>, on peut faire de la validation crois\u00e9e entre plusieurs champs :</p> <pre><code>from pydantic import BaseModel, field_validator, model_validator\n\n\nclass Product(BaseModel):\n    name: str\n    price: float\n    quantity: int\n\n    @field_validator(\"name\")\n    @classmethod\n    def name_must_not_be_empty(cls, v: str) -&gt; str:\n        if not v.strip():\n            raise ValueError(\"Le nom du produit ne peut pas \u00eatre vide\")\n        return v.strip().title()\n\n    @field_validator(\"price\")\n    @classmethod\n    def price_must_be_positive(cls, v: float) -&gt; float:\n        if v &lt;= 0:\n            raise ValueError(\"Le prix doit \u00eatre positif\")\n        return round(v, 2)\n\n    @model_validator(mode=\"after\")\n    def check_stock_value(self) -&gt; \"Product\":\n        \"\"\"Validation qui d\u00e9pend de plusieurs champs \u00e0 la fois.\"\"\"\n        if self.price * self.quantity &gt; 1_000_000:\n            raise ValueError(\"La valeur totale du stock ne peut pas d\u00e9passer 1 000 000\")\n        return self\n\n\ndef main() -&gt; None:\n    # Le field_validator transforme le nom automatiquement\n    product = Product(name=\"  laptop  \", price=999.999, quantity=10)\n    print(product)  # name='Laptop', price=1000.0\n\n    # model_validator v\u00e9rifie la combinaison prix * quantit\u00e9\n    try:\n        Product(name=\"Expensive Item\", price=10000, quantity=200)\n    except Exception as e:\n        print(f\"Erreur : {e}\")\n\n    # field_validator rejette un nom vide\n    try:\n        Product(name=\"   \", price=10, quantity=1)\n    except Exception as e:\n        print(f\"Erreur : {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#serialisation-et-deserialisation","title":"S\u00e9rialisation et d\u00e9s\u00e9rialisation","text":"<p>Pydantic g\u00e8re nativement les mod\u00e8les imbriqu\u00e9s et la s\u00e9rialisation (<code>model_dump</code>, <code>model_dump_json</code>) / d\u00e9s\u00e9rialisation (<code>model_validate</code>, <code>model_validate_json</code>), ce qui est particuli\u00e8rement utile pour les APIs :</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zip_code: str\n\n\nclass Employee(BaseModel):\n    name: str\n    role: str = \"Developer\"\n    address: Address\n    skills: list[str] = Field(default_factory=list)\n\n\ndef main() -&gt; None:\n    # Pydantic g\u00e8re nativement les mod\u00e8les imbriqu\u00e9s\n    employee = Employee(\n        name=\"Alice\",\n        role=\"Senior Developer\",\n        address=Address(street=\"123 Main St\", city=\"Paris\", zip_code=\"75001\"),\n        skills=[\"Python\", \"FastAPI\"],\n    )\n    print(employee)\n\n    # S\u00e9rialisation en dictionnaire\n    employee_dict = employee.model_dump()\n    print(employee_dict)\n\n    # S\u00e9rialisation en JSON\n    employee_json = employee.model_dump_json(indent=2)\n    print(employee_json)\n\n    # D\u00e9s\u00e9rialisation depuis un dictionnaire (utile pour les APIs)\n    data = {\n        \"name\": \"Bob\",\n        \"address\": {\"street\": \"456 Rue de Rivoli\", \"city\": \"Paris\", \"zip_code\": \"75004\"},\n        \"skills\": [\"SQL\", \"Terraform\"],\n    }\n    employee_from_dict = Employee.model_validate(data)\n    print(employee_from_dict)\n\n    # D\u00e9s\u00e9rialisation depuis du JSON\n    json_str = '{\"name\": \"Charlie\", \"address\": {\"street\": \"789 Avenue\", \"city\": \"Lyon\", \"zip_code\": \"69001\"}}'\n    employee_from_json = Employee.model_validate_json(json_str)\n    print(employee_from_json)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#exercices","title":"Exercices","text":""},{"location":"cours-3-class-et-dataclass/#exercice-1-from-class-to-dataclass","title":"Exercice 1 : From Class to Dataclass","text":"<p>Convertir les classes suivantes en dataclasses de mani\u00e8re \u00e0 ce que les initialisateurs g\u00e9n\u00e9r\u00e9s aient le m\u00eame comportement que la classe classique :</p> <pre><code># Exercice : Convertir des classes en dataclasses\n# Convertissez les classes suivantes en dataclasses de mani\u00e8re \u00e0 ce que\n# les initialisateurs g\u00e9n\u00e9r\u00e9s aient le m\u00eame comportement que la classe classique.\n\n\nclass A:\n    def __init__(self) -&gt; None:\n        self._length = 0\n\n\nclass B:\n    def __init__(self, x: int, y: str = \"hello\", values: list[int] | None = None) -&gt; None:\n        self.x = x\n        self.y = y\n        self.values = values if values else []\n\n\nclass C:\n    def __init__(self, a: int = 3) -&gt; None:\n        self.a = a\n        self.b = a + 3\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#exercice-2-systeme-de-gestion-de-bibliotheque-dataclass","title":"Exercice 2 : Syst\u00e8me de gestion de biblioth\u00e8que (Dataclass)","text":"<p>Cr\u00e9er un syst\u00e8me de gestion de biblioth\u00e8que en utilisant les dataclasses avec <code>order</code>, <code>frozen</code>, <code>default_factory</code> et les enums :</p> <pre><code># Exercice : Syst\u00e8me de gestion de biblioth\u00e8que\n# Cr\u00e9ez un syst\u00e8me de gestion de biblioth\u00e8que en utilisant les dataclasses.\n#\n# 1. Cr\u00e9ez un enum `Genre` avec les valeurs : FICTION, NON_FICTION, SCIENCE, HISTORY, TECHNOLOGY\n#\n# 2. Cr\u00e9ez une dataclass `Book` avec :\n#    - title (str)\n#    - author (str)\n#    - genre (Genre)\n#    - isbn (str)\n#    - pages (int)\n#    - available (bool, par d\u00e9faut True)\n#    - Utilisez `order=True` pour permettre le tri des livres par titre\n#    - Utilisez `frozen=True` pour l'immuabilit\u00e9 (les infos d'un livre ne devraient pas changer)\n#\n# 3. Cr\u00e9ez une dataclass `Library` avec :\n#    - name (str)\n#    - books : liste de Book (utilisez default_factory)\n#    - Une m\u00e9thode `add_book(book)` qui ajoute un livre \u00e0 la biblioth\u00e8que\n#    - Une m\u00e9thode `find_by_genre(genre)` qui retourne tous les livres d'un genre donn\u00e9\n#    - Une m\u00e9thode `find_by_author(author)` qui retourne tous les livres d'un auteur donn\u00e9\n#\n# 4. Dans main() :\n#    - Cr\u00e9ez une Library\n#    - Ajoutez au moins 4 livres de genres diff\u00e9rents\n#    - Trouvez tous les livres d'un genre sp\u00e9cifique\n#    - Triez les livres par titre avec sorted()\n#    - Affichez les r\u00e9sultats\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#exercice-3-validation-dinscription-utilisateur-pydantic","title":"Exercice 3 : Validation d'inscription utilisateur (Pydantic)","text":"<p>Cr\u00e9er un syst\u00e8me de validation d'inscription avec <code>@field_validator</code>, les contraintes <code>Field</code>, et la s\u00e9rialisation :</p> <pre><code># Exercice : Validation d'inscription utilisateur avec Pydantic\n# Cr\u00e9ez un syst\u00e8me de validation d'inscription en utilisant Pydantic.\n#\n# 1. Cr\u00e9ez un mod\u00e8le Pydantic `UserRegistration` avec :\n#    - username (str) : minimum 3 caract\u00e8res, maximum 20 caract\u00e8res, alphanum\u00e9rique uniquement\n#    - email (str) : doit \u00eatre un email valide (utilisez EmailStr de Pydantic)\n#    - password (str) : minimum 8 caract\u00e8res\n#    - age (int) : doit \u00eatre entre 13 et 120\n#    - newsletter (bool, par d\u00e9faut False)\n#\n# 2. Ajoutez un @field_validator pour `password` qui v\u00e9rifie :\n#    - Au moins une lettre majuscule\n#    - Au moins un chiffre\n#    - Au moins un caract\u00e8re sp\u00e9cial (!@#$%^&amp;*)\n#\n# 3. Ajoutez un @field_validator pour `username` qui :\n#    - Supprime les espaces en d\u00e9but/fin\n#    - Convertit en minuscules\n#\n# 4. Dans main() :\n#    - Cr\u00e9ez un utilisateur valide et affichez-le\n#    - Essayez de cr\u00e9er un utilisateur avec un mot de passe invalide et capturez l'erreur\n#    - Essayez de cr\u00e9er un utilisateur avec un email invalide et capturez l'erreur\n#    - S\u00e9rialisez l'utilisateur valide en JSON avec model_dump_json()\n</code></pre>"},{"location":"cours-3-class-et-dataclass/#exercice-4-systeme-de-commandes-e-commerce-pydantic","title":"Exercice 4 : Syst\u00e8me de commandes e-commerce (Pydantic)","text":"<p>Cr\u00e9er un syst\u00e8me de commandes avec des mod\u00e8les imbriqu\u00e9s, <code>@model_validator</code>, et la s\u00e9rialisation/d\u00e9s\u00e9rialisation :</p> <pre><code># Exercice : Syst\u00e8me de commandes e-commerce avec Pydantic\n# Cr\u00e9ez un syst\u00e8me de validation de commandes en utilisant Pydantic.\n#\n# 1. Cr\u00e9ez un enum `OrderStatus` avec : PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED\n#\n# 2. Cr\u00e9ez un mod\u00e8le Pydantic `Product` avec :\n#    - name (str) : non vide\n#    - price (float) : doit \u00eatre &gt; 0, arrondi \u00e0 2 d\u00e9cimales via un validator\n#    - quantity (int) : doit \u00eatre &gt;= 1\n#\n# 3. Cr\u00e9ez un mod\u00e8le Pydantic `Order` avec :\n#    - order_id (str)\n#    - customer_email (str)\n#    - products (list[Product]) : doit contenir au moins 1 produit\n#    - status (OrderStatus, par d\u00e9faut PENDING)\n#    - discount_percent (float, par d\u00e9faut 0) : doit \u00eatre entre 0 et 50\n#\n# 4. Ajoutez un @model_validator qui :\n#    - Calcule et stocke le `total_price` (somme de price * quantity pour chaque produit)\n#    - Applique la r\u00e9duction au total\n#    - Rejette la commande si le total apr\u00e8s r\u00e9duction est inf\u00e9rieur \u00e0 1.0\n#\n# 5. Ajoutez une m\u00e9thode `cancel()` qui change le statut en CANCELLED uniquement si pas d\u00e9j\u00e0 DELIVERED\n#\n# 6. Dans main() :\n#    - Cr\u00e9ez une commande valide avec plusieurs produits et affichez-la\n#    - S\u00e9rialisez en dictionnaire avec model_dump() et affichez\n#    - Essayez de cr\u00e9er une commande avec une liste de produits vide et capturez l'erreur\n#    - Essayez de cr\u00e9er une commande avec une r\u00e9duction &gt; 50% et capturez l'erreur\n</code></pre>"}]}